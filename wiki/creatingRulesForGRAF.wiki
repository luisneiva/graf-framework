#summary Tutorial on how to add rules

WORK IN PROGRESS

This tutorial describes the steps required to add an Action to GRAF - including how to add the Action to the model file and how to make Rules that implement its execution.

= 1. Identify the relevant UML Section =

Find the section in the Specification that talks about the Action you want to implement. It should be part of Chapter 13. Once you've found it, the most important sub-sections are:
  * Description: what the Action is supposed to do
  * Attributes, Associations: these features are used during execution - they may need to be added to the model
    * Note that 'no additional attributes/associations' may indicate that the Action inherits attributes or associations from a parent Action.  

= 2. Add the Action to the UML Model =

  # Open the .uml file in Eclipse's UML Editor
  # Add the Action to the model tree
    # Actions can be added as part of a State Machine, or a Method. 
      # State Machine:
        * Add an Activity to the State (right-click on the state, then select New Child -> Do Activity -> Activity)
        * Right-click on the Activity, then select New Child -> Node -> `[`the Action`]`
      # Method:
        * Add an Activity to the Class (right-click on the class, then select New Child -> Classifier Behavior -> Activity). This Activity is treated like a Method by UML. Give the Activity a unique name by editing the Properties view (right-click on the Activity, select Show Properties View)
        * Right-click on the Activity, then select New Child -> Node -> `[`Action`]`
        * Add an Operation to the Class. Give the Operation a unique name. The Operation acts as an interface for other classes to access the Method.
        * Click on the Method field in the Operation's Properties view, then the `[`...`]` button that appears, to open a dialogue. Select the method Activity and click OK. 
  # Fill in any other Properties that will be used in implementing the rule. These are the Action's Attributes from the Specification. You may not need to fill them all in.
  # Add 'child' objects that correspond to the Action's Associations (right-click, New Child -> `[`Association`]` -> `[`Object`]`).
    # Name and fill in the required properties of the child objects - you may not need all the fields.
  # Open and edit the Properties.txt file so that `Printgraphs` is set to true.
  # Run GRAF. Select the model you just edited and open it. Click through until the new Action becomes available to generate the .dot file 'image' of the underlying GRAF.
  # Click on the new Action when it appears - you should see an error message, since we haven't made the rules for the Action yet.
  # Exit GRAF.

== A more complicated Example ==

For this example, our Method will create a new object, create a link between the new object and an existing object, and return the result to the calling object. In UML, methods always return the result to the calling object.
    * That is, the Method will contain !AcceptCallAction, !CreateObjectAction, !CreateLinkAction, and !ReplyAction.
  # Set up the Method as described above.
  # Add !ReplyAction.
    * Note that !ReplyAction is added at the 'top' of the Action tree, because it is the _last_ thing to be executed.
  # !ReplyAction has two input pins, !ReturnInformation and !ReplyValue. 
    * The !ReturnInformaton pin holds the 'address' of the calling object.
      # !ReturnInformation gets its data from the execution of !AcceptCallAction, so right-click on !ReplyAction, select Return Information -> Action Input Pin. Name the Action Input Pin something like !ReplyAction-!ReturnInformation.
      # Put !AcceptCallAction 'on' the Action Input Pin (right-click the Action Input Pin, select New Child -> From Action -> !AcceptCallAction.
      # !AcceptCallAction requires two ordinary Output Pins and a Trigger. Add these as described above.
        * Note that the Event Property value of the trigger should be a Call Event - you will need to create one if it doesn't already exist
    * The !ReplyValue pin holds the value that is to be returned to the caller. In this case, it should hold the new, linked object.
      # The object must first be created, then linked. We add these Actions in reverse order, so add an Action Input Pin for !ReplyValue, and put !CreateLinkAction 'on' it.
      # !CreateLinkAction requires two !endDatas and one !inputValue. The endDatas' End property values refer to the classes of the objects that are to be linked.
      # The !inputValue holds the object that is to be linked. In this case, that object is to be created by !CreateObjectAction, so !inputValue should be an Action Input Pin holding !CreateObjectAction.
      # !CreateObjectAction has a single ordinary Output Pin called 'result'. Add this to complete the Method tree structure.


= 3. Editing the Rule Sequence File =

GRAF uses the GTSRulesSeq.xml file to determine which rule to apply when a particular Action is invoked. 
  # Add a new 'action' node to the file.
  # Give it 'name' and 'rule' child nodes.
  # Set the 'name' attribute to the name of the Action.
  # Set the 'rule' attribute to the name of the new rule.

= 4. Editing the Rules file =

== Stage 1: LHS ==
  # If you haven't already done so, run GRAF with Printgraphs set to true. Load the relevant model and click through to the state just before the new Action would be executed, then exit.
  # Use '!GraphOutputs/conversionFiles/dotToImg2 stateN.dot' (where N is the state just before the rule is applied) or the dotty.exe Graphviz program to view the stateN.dot file generated from the model as a graph.
  # Find the Action in the graph image. Keep this file open. You might want to sketch the nodes involved in the Action - especially if they are scattered across the graph. Use this to make a draft of the rule using the Description from the Specification.
  # Open AGG from the 'agg_V164' folder in the GRAF repository.
    * A detailed explanation of AGG's interface and functionality can be found [howToCreateRulesInAGG here]. The following is a brief description of the recommended process.
    # Open the GRAF graph grammar.
    # Create a new blank rule and give it a name - the name you added to the GTSRulesSeq.xml file.
    # Open the LHS window for that rule.
    # Add the nodes and edges for the LHS (pre-condition). Make sure that every node that will be used in the rule is included. 
      # Give the nodes and edges unique names, using the Attributes view.
      # Where you want to match a node or edge name to the graph, put the name in "double quotes". Where the name is a variable, don't use quotes.
    # Use the 'IR' button to generate a mapped right-hand-side for the rule.
    # Open the 'Attributes' view.
    # Open the 'Attribute Context' tab.
    # 'Check' the box in the 'In' column belonging to the nodes representing the host instance and the instance of the Action itself. This tells AGG what input parameters to expect when applying the rule, which it uses to 'match' to the graph.
    # Save the file. Keep AGG open.
  # Edit the Properties.txt file so that 'PrintRules' is set to true.
  # Run GRAF. The generated rule.dot files should be converted to images automatically. Open the new rule and check that looks ok. If there are errors, return to AGG and fix the problem, and repeat.
  # Then click through the model until the new Action is available. Click on the Action. If the rule is applied with no errors, proceed to the next stage. Otherwise, there are two possible problems:
    # In the .xml file: either the Action name is not correct or the rule name doesn't match. If this occurs, simply fix the .xml file, save and try again.
    # In the rule file: the rule doesn't match. Usually, either:
      # The inputs are incorrect.
      # The "name" of a node or edge doesn't match the graph.
      # An edge is pointing in the wrong direction.
    # Use the stateN.dot (where N is the state just before the rule was applied) file to check that the rule LHS is accurate. Remember to create a new identic RHS and save before retrying.
    # If all else fails, remove nodes one by one until the rule matches. Then add the nodes and edges back in one at a time, testing each time.

== Stage 2: RHS ==
Now that you know that the LHS of the rule matches, make the necessary changes to the RHS to implement the Description. Test the new rule in GRAF as before. Remember to check the underlying graph and generated rule image - logic errors will not necessarily be obvious from the object diagram view.

= 5. Update Documentation =
When the rule is working, update the rule documentation to include the new rule, and any assumptions or deviations from the description that you made while implementing it.