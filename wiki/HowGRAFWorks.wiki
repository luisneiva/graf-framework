== How GRAF works ==

This is a summary of the lesson Oscar gave at the meeting on the 18th March 2010.
This applies to the version of GRAF from the end of 2009.

=== Input files ===

When you run GRAF you select a .modeltest file as the input. This is an example .modeltest file:
{{{
Microwave.uml

m1 : Microwave
{NotCooking}

f1 : Food
{NotCooked}
temperature = 3

b1 : Beeper
{Silent}

m1 <cookedBy, cooks> f1
m1 <in,has> b1
}}}

The first line is a reference to a .uml file. .uml files can be generated by following the supplied [http://code.google.com/p/graf-framework/wiki/howToAddModels
 guide]. .uml files contain a model. The rest of the modeltest file details an instance of the model.

In the line m1 : Microwave<br>
m1 is the name of the object. m1 can be anything.<br>
Microwave is the name of the class. This name must appear in the uml file.

In the line {!NotCooking}<br>
!NotCooking is the name of a state. This name must appear in the uml file and it must be the name of a state for the above class.<br>

In the line temperature = 3<br>
temperature is the name of an attribute. This name must appear in the uml file and it must be an attribute for the above class.<br>
3 is the value of the attribute. This can be anything.<br>

For GRAF, the model will consist of a class diagram and state machines such as: <br>
<br> 
http://graf-framework.googlecode.com/files/MicrowaveUML.jpg

A system state is a combination of model, instance and metamodel (eg. UML). From the .uml file and the .modeltest file, GRAF takes a system state as input.

=== Execution ===

GRAF represents the system state internally as one gigantic graph. GRAF also provides a graphical representation (an object diagram annotated with state information) to display to the user.

From a system state it is possible to transition to another system state. There are three ways to transition:
  * Execute an action (click on the action)
  * Accept an internal event (click on the event)
  * Accept an external event (right click on an object and choose an event to send)

When this happens the graph behind the scenes is transformed and a new object diagram GUI is generated and the process starts again.

In order to find out how to transform the graph to the next system state, a graph transformation rule is used. All graph transformation rules are contained in GTSRules.ggx. Currently there are about 6 rules like !AcceptEvent and !SendSignal. You can change these rules without changing the GRAF code and the model's behaviour will change.

The diagram below summarises the above. <br>
<br> 
http://graf-framework.googlecode.com/files/simplearch.jpg