#summary Preshowcase presentation preparation

==3100 Pre-Showcase Presentation==
1.Introduction + Statement of Purpose<br>
2.UML and its problems<br>
 a.Expense<br>
 b.Unavailability<br>
 c.No ‘definitive’ implementation of UML - or attention paid to differences/assumptions/deviations. UML isn’t just diagrams. It also defines behaviour. UML is large and complex. The proprietary tools give an 0th level answer as to what a model means and does – there is no explanation and the user must take it on faith. Because UML is loosely defined, any animator’s interpretation is just that – one of several possible interpretations. Generally, animators will not make this explicit. Why should they? Their interpretation may not be wrong, exactly, But realising that different interpretations are possible is important. <br>
 d.Demonstration of ‘semaphore’ model – pose question “what happens next?” Answer: it’s a trick question. UML is defined as non-deterministic, so either result is valid.<br>
3.    Define GRAF
  a.    Define: Animator
    i.    What it is
      1.    An ‘animator’ is an application that displays an instance of a model, which can mock-executed according to the rules that the model defines. It lets us see the ‘behavior’ of the model in a dynamic way, instead of just looking at a state machine or sequence diagram
    ii.    Why animate?
      1.    Educate (yourself and others) about your model
        a.    The client seeks to address the scenario in which a model is ‘sketched’ as a loose concept and then presented to others as a definition of what needs to be done. How can we guarantee that the author’s idea is captured correctly? One way might be for the author to verify their own model by ‘stepping through’ (animating) and making sure that it works as they expect. And of course others – not just the author of the model – could do this too
      2.    Part of a tool-chain to create a high-level view of code 
        a.    This is necessary if we are to take MDD seriously. While our clients aren’t advocating Model Driven Development specifically, they do see GRAF’s educational function as being particularly applicable for Model Driven Development
    b.    Define: Graph-transformations
      i.    What are they?
        1.    Wikipedia: “graph-transformation concerns the technique of creating a new graph out of an original graph using some automatic machine”
        2.    You start with a base graph – some nodes and arcs between the nodes
        3.    And a rule – this is two smaller graphs – a ‘before’ stage and an ‘after’ stage
        4.    If the ‘before’ stage matches some part of your base graph, then you change the base graph to match the ‘after’ stage
        5.    That is, the graph is transformed
      ii.    How is that applied to UML?
        1.    One of our clients argued in his thesis that you can represent a model’s state as a graph – a set of nodes and edges
        2.    Once you’ve done this, you can define graph-transformation rules to mimic the operation of the most basic UML behavior – Actions
      iii.    Why is that useful?
        1.    We’ve already said why animators can be useful. Using graphs and graph-transformation rules allows us to formally define the implementation of Actions, rather than relying on code and hand-waving. Defining UML in this way at the lowest level will reduce the complexity and ambiguity of the language
    c.    Define: Reference
      i.    What it originally meant v what it means to GRAF
      ii.    Classically, a ‘reference’ animator would be an authoritative implementation of UML against which all others can be judged. However, the OMG does not endorse UML implementations in this way
      iii.    So we use reference in a weaker sense – that GRAF can be used as a reference in the same way a dictionary can – you can use it to find out stuff about your model
    d.    Define: Framework 
      i.    GRAF provides an animator framework – meaning that it should be extensible to languages other than UML
    e.    Re-state definitions as one sentence (refer to statement of purpose)
      i.    So GRAF is a reference animator that explicitly uses graph-transformation theory to provide a clear, low-level formal definition of UML
3b.    Technology used by GRAF
  a.    Eclipse/java
    i.    We – or rather the 2009 team – chose Eclipse because it is a widely-used, freely available platform with a culture of extensibility. It’s not just that we developed GRAF using Eclipse – it is based on the Eclipse UML implementation and runs as an Eclipse plugin. By tying GRAF to a recognized platform, we hope to make it more accessible to users
  b.    AGG
    i.    AGG is a graph-transformation engine implemented in java. We use it to do that actual work of applying the graph-transformation rules.

4.This Year’s Project<br>
  a.What we’ve done<br>
   i.Coverage of GRAF as a % of UML Actions<br>
   ii.Additional new functionality<br>
   iii.Evaluation of what we’ve done with reference to the success criteria<br>
  b.How will this help our client?<br>
   i.State the client’s original goals and their context (Greg’s thesis, desire to create ‘technology transfer’ across from academia to industry)<br>
   ii.Conceptual/ practical problems with GRAF as an industry project<br>
   iii.Emerging/ changed goals<br>
    1.Education (how/why this happened)<br>
    2.Other changes eg to scope<br>
5.GRAF in the Future<br>
 a.Challenges<br>
  i.New functionality<br>
  ii.New users/ uses for GRAF<br>
  iii.Extending the GUI interface<br>
  iv.Integrating with existing tools<br>
 b.Opportunities<br>
  i.UML – one of the most widely-used, most misunderstood languages <br>
  ii.‘technology transfer’<br>