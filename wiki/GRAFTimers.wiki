#summary How timers work in GRAF
=Timers=
At the end of the 2010 project, the GRAF team attempted to implement [xtUMLTimers xtUML style timers] in GRAF. It became apparent that our implementation method was not optimal and there wasn't enough time to finish it and it was a kludge. Though timers aren't part of the UML definition, they're common in xtUML. This page serves as a guide for how not to implement timers if a future group chooses to do so.

==UML vs xtUML==
The first thing you need to decide when implementing timers is whether to do it according to UML or xtUML. UML doesn't have timers so you'd have to build them from the ground up using such things as Durations and !DurationIntervals. This would take a lot of effort and research into the UML definition.

We followed xtUML. Our implementation of GRAF is for UML not xtUML, but we aimed to put in some kind of switch which would turn on xtUML mode and enable timers. Since xtUML has no explicit semantics unlike UML (informal English though it may be) we can take some more liberties in how we interpret and implement it.

Or, you could follow a profile of UML that is designed for timers. This would be similar to the xtUML option.

==Failed Implementation==
We connected objects to the Actor object. When an object sent a timed signal, it went to the Actor (!SendSignalAction). A timer would run and then the timed signal would be received (!ActorSendSignal). The use of the Actor node was an arbitrary kludge. Don't do this.

An old page dealing our failed implementation is [OldGrafTimers here].

==Challenges==
The main challenge is we use the .uml files to define our models. If you do an xtUML implementation of timers then you won't be able to put it in the .uml file because it only has UML elements, which doesn't include timers. An alternative might be to add something in the .modeltest file.

In GRAF we should do all the behaviour stuff at the graph level using graph transformations. But we can't do this using timers. A timer will have to exist somewhere higher up in the code, using the Java Timer class or something like that.

In our failed implementation, the timed events worked but when the timers expired you couldn't see the changes in the graph reflected in the object diagram. This was because we didn't implement the transformations in the normal part of the code. !EventTimer objects stored the timed events and executed the delayed graph transformations. A refresh action would have been needed to update the object diagram to reflect the graph. But doing a refresh would have seriously violated the connections in the architecture:

http://graf-framework.googlecode.com/files/HighLevelDesign.png

In a correct implementation you should not have to duplicate any of the code that applies graph transformations.

Note that !EventTimer.java and the !createDelayEvent method in !ODObject.java are still on svn and it could be worth having a look at. But !EventTimer.java isn't used and all the other timer code has been taken out.