#summary How timers once worked in GRAF

*This page is out of date*<br>
*The stuff on this page is no longer part of GRAF*

=Timers=
There's a partial, ideosyncratic implementation of timers in GRAF. This page explains it, but you should also take a look the microwaveTimer model and try executing it.

== Purpose ==
We implemented timers to enable the animation of Shayne Flint's [http://cs.anu.edu.au/student/comp3110/ microwave model]. This is an xtUML model and contains statements like Generate x to y delay 20.

== UML vs xtUML ==
UML doesn't have timers because they're too high level. See [xtUMLTimers this explanation]. We take thorough care in implementing UML features according to the definition (even if it is in informal English). But xtUML has no section on semantics, formal or informal. Therefore we have taken a more flexible approach in implementing timers, doing what fits the existing code best.

== Design Overview ==
Instead of sending a signal which takes 20 seconds to arrive, we send a signal to an actor object. The actor waits for 20 seconds and then sends a signal back.

We try and implement all features as low down as possible. That is, graphs, not code. But in the case of timers we necessarily use a lot of high level code to deal with it.

== How to use a timer ==
To set up a timer at the moment is an involved process. If timers are popular then it would be beneficial to simplify this.

The first step is to change the .modeltest file. Add a line like the following:
{{{
m1 <fromMicrowave,toActor> actor1
}}}
m1 will have to be an existing object in the .modeltest file. actor1 will have to be an object that _does not_ exist in the .modeltest file. actor1 is the instance of the Actor which is automatically created in GRAF. This line creates a link from the object to be timed to the actor, which we hijack to do the timer stuff. We use the link as a means of getting the signal to the actor.

The second step is to set up the .uml file. See the image below.

http://graf-framework.googlecode.com/files/timerform.jpg

The beep and beepSignal nodes are normal untimed nodes. startTimer and startTimerSignal are the equivalent nodes, but timed. A timed signal needs a property called _setTimer_ to be interpreted as a timed signal. The literal integer child of this is the time that the signal will be delayed. You'll need a !SendSignalAction somewhere else in the file to send the signal (external actors currrently can't send timed signals).

== How timers work ==
The sequence begins at the graph level. A normal signal is sent. The code then examines it and discovers it's a timed object. It can tell it's a timed object because it's being sent to the actor (an arbitrary kludge in the implementation). At this point the code takes over and stores who sent the signal and the time of the signal. When the timer expires the code executes !ActorSendSignal. This will send a signal back to the sender, bringing it back to the graph level.

== Limitations ==
  * Only one timed event can happen at a time
  * Timed objects can only send timed signals to themselves
  * Timed events don't use the normal code due to the need for concurrency. Therefore there's some nasty duplication, specifically in ODObject.createDelayEvent() of !PluginModel
  * (to be confirmed) This may not be completed by the end of the year